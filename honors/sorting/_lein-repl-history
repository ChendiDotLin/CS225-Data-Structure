(def arr [1 2 3 5 8])
(swap arr 2 3)
(cas arr 2 3)
(cas [8 7 6 5 4 3] 2 3)
(pmap inc [1 23])
(doc pmap)
(doc partition)
(partition 2 [1 2 3 4 5 6])
(reduce cas [4 3 2 1] [[1 2] [3 4]])
(reduce cas [4 3 2 1] [[1 2] [3 0]])
(reduce cas [4 3 2 1] [[1 2] '(3 0)])
(reduce cas [4 3 2 1] ['(3 0)])
(reduce cas [4 3 2 1] ['(1 0)])
(reduce cas [4 3 2 1] [[1 0]])
(reduce cas [4 3 2 1] [[1 2]])
(reduce cas [4 3 2 1] [[0 1]])
(reduce cas [4 3 2 1] [[0 1] [2 3])
(reduce cas [4 3 2 1] [[0 1] [2 3]])
(reduce cas [4 3 2 1] (partition 2 [0 1 2 3]))
(multi-cas [4 3 2 1] [0 1 2 3])
(future (+ 1 2))
(deref *1)
(n-sort [5 4 3 2 1 0] n6)
(defn split-bit [v] [(conj v 0) (conj v 1)])
(split-bit [0 0])
(mapcat split-bit (split-bit [0 0])
)
(doc iterate)
(doc nth)
(nth (iterate #(mapcat bitsplit %) [[]]) 4)
(nth (iterate #(mapcat bit-split %) [[]]) 4)
(nth (iterate #(mapcat split-bit %) [[]]) 4)
(cas [4 3 2 1] [1 2])
(cas [40 30 20 10] [1 2])
(doc par)
(doc pcalls)
(doc pvalues)
(pvalues (+ 1 2) (+ 4 5))
(time (pvalues (+ 1 2) (+ 4 5)))
(time (cons (+ 1 2) (+ 4 5)))
(time (list (+ 1 2) (+ 4 5)))
(time (pvalues (+ 1 2) (+ 4 5)))
(n-sort [5 4 3 2 1 0] n6)
(defn split-bit [v] [(conj v 0) (conj v 1)])
(doc verify)
(cas [1 2 3] [0 1])
:Q
(cas [5 3 4 6 2] [2 3])
lein repl
